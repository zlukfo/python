# Разбираемся с asyncio
Начиная с версии 3.5 можно указать что функция должна ныполняться в асинхронном режиме. Для этого перед **def** нужно вставить **async**
``` python
async def f1():
    print ('Выполняется функция f1')
```
Но вызов такой функции как **f1()** приведет о ошибке. Асинхронные функции должны выполняться в **цикле событий**. Самый простой способ создать такой цикл
``` python
import asyncio
async def f1():
    print ('Выполняется функция f1')
asyncio.run(f1())
```
засунуть в цикл событий функцию не помеченную *async* не получится - выдаст ошибку

Теперь наверное самое важное - для чего нужна асинхронность. Есть функция, время выполнения которой занимает долгое время. В обычном случае (без асинхронности) программа ждет когда завершится эта функция и только псле этого переходит к выполнению следующего кода. Но часто бывает, что ожидать завершения "долгой" функции нет необходимости. Пока она выполняется можно параллельно выполнять следующий блок кода. Если это реализовать - общее время выполнения программы уменьшается.

Здесь необходимо важное уточнение - мы рассматриваем случай когда долгое выполнение функции зависит не от операций, загружающих вычислительные мощности системы, а от вынужденного простоя, например, функция отправила запрос на внешний сервер и простивает в ожидании ответа, чтобы потом его обработать. В этом случае время ожидания можно использовать более эффективно, выполняя в это время другие команды и функции программы, например, отправить еще несколько сотен запросов на сервер.

Как выполняется переключение функций
Ключевые понятия
**Сопрограмма** - Функция, которая может приостановить свое выполнение и продолжить позже. *Любой **блокирующий** код внутри сопрограммы блокирует выполнение цикла событий и всех остальных сопрограмм*

---------------------------

Для реализации асинхнонного прогаммирования используются 2 коючевых слова

*await* - это ключевое слово которое ставится перед функцией-сопрограммой (корутиной) или специальным объеком, у которого реализован магический метод __await__, возвращающий итератор, которое указывает на то, что программа *может* переключится на выполнение последующего кода, пока ожидается завершение текущего, помеченного *await*

*async* - ключевое слово которое определяет, что блок кода следующий после него может выполняться асинхронно. Прежде всего это касается платформенных сопрограмм - конструкция **async def**/ Какие еще _____

*цикл событий* - вернемся к *await* - может переключаться на выполнение другого кода (выполняется асинхронно) -  не значит делает это. Чтобы блок кода выполнялся асинхронно нужно включить его в цикл событий, который выполняет все включенные в него блоки кода на конкурентной основе.


## Curio - альтернатива asyncio
**Curio** -  библиотека написанная Дэвидом Бизли. Попытаемся понять анинхронное программирование с ее помощью

Пример 1
``` python
import curio
import time

async def f(n):
    print (f'Начало выполнения {n}: {time.ctime()}')
    await curio.sleep(n)
    print (f'Конец выполнения {n}: {time.ctime()}')

async def parent():
    print (f'Старт программы: {time.ctime()}')
    await f(2)
    await f(5)

if __name__ == '__main__':
    curio.run(parent)
```

здесь, несмотря что перед f(2) и f(5) указано await вызовы функцией выполняются последовательно - потому что они не включены в цикл событий. Давайте добавим наши функции в цикл событий
``` python
async def parent():
    print (f'Старт программы: {time.ctime()}')
    await curio.spawn(f, 2)
    await curio.spawn(f, 5)
``` 
как видно из вывода программы - обе они запустились ожновременно но при этом функция *parent* не отслеживает их завершения (а значит не контролирует результат выполнения). чтобы испавить это, изменим функцию
``` python
async def parent():
    print (f'Старт программы: {time.ctime()}')
    f_small = await curio.spawn(f, 2)
    f_big = await curio.spawn(f, 5)

    await f_small.join()
    await f_big.join()
```
теперь все правильно


